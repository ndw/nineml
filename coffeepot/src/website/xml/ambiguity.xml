<chapter xmlns="http://docbook.org/ns/docbook"
         xmlns:xi='http://www.w3.org/2001/XInclude'
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xml:id="ambiguity"
         version="5.2">
<title>Ambiguity</title>

<para>Ambiguity is not an error. The fact that Invisible XML grammars
allow ambiguity is a feature. It’s also generally observed as the
combination of a grammar and an input. Consider this grammar:</para>

<example xml:id="ambig01">
<title>SNL™ Shimmer Sketch</title>
<programlisting linenumbering="unnumbered"
  ><xi:include parse="text" href="examples/ambig01.ixml"/>
</programlisting>
</example>

<para>(If you aren’t familiar with the Saturday Night Live “Shimmer
Floor Wax” sketch, now would be the time to go search the web.)</para>

<para>Parsed against the input “custard”, it says dessert topping:</para>

<programlisting linenumbering="unnumbered"
><![CDATA[$ coffeepot -pp -g:examples/ambig01.ixml custard
<product>
   <dessert-topping>custard</dessert-topping>
</product>]]></programlisting>

<para>Parsed against the input “paste-wax”, it says floor wax:</para>

<programlisting linenumbering="unnumbered"
><![CDATA[$ coffeepot -pp -g:examples/ambig01.ixml paste-wax
<product>
   <floor-wax>paste-wax</floor-wax>
</product>]]></programlisting>

<para>Parsed against “Shimmer”, it says:</para>

<programlisting linenumbering="unnumbered"
><![CDATA[$ coffeepot -pp -g:examples/ambig01.ixml Shimmer
There are 2 possible parses.
<product xmlns:ixml="http://invisiblexml.org/NS" ixml:state="ambiguous">
   <floor-wax>Shimmer</floor-wax>
</product>]]></programlisting>

<para>This is an example of an essential ambiguity; you can’t “fix”
this grammar. But let’s dig a little deeper anyway. For a small number
of parses, one way to investigate the ambiguity is to simply list them
all with <option>--parse-count:all</option>:</para>

<programlisting linenumbering="unnumbered"
><![CDATA[$ coffeepot -pp -g:examples/ambig01.ixml --parse-count:all Shimmer
<ixml parses='2' totalParses='2'>
<product xmlns:ixml="http://invisiblexml.org/NS" ixml:state="ambiguous">
   <floor-wax>Shimmer</floor-wax>
</product><product xmlns:ixml="http://invisiblexml.org/NS" ixml:state="ambiguous">
   <dessert-topping>Shimmer</dessert-topping>
</product></ixml>]]></programlisting>

<para>Alternatively, we can ask the parser to describe the ambiguity with
<option>--describe-ambiguity</option>:</para>

<programlisting linenumbering="unnumbered"
><![CDATA[$ coffeepot -pp -g:examples/ambig01.ixml --describe-ambiguity --no-output Shimmer
Found 2 possible parses.
At /product
    ✔ floor-wax«1-7»
      dessert-topping«1-7»]]></programlisting>

<para>This indicates that the characters from 1 to 7 in the input can be matched
as a <literal>product</literal> containing a <literal>dessert-topping</literal> or
a <literal>floor-wax</literal>. This is another case where the forest graph
can be useful.</para>

<figure xml:id="ambig01-shimmer.svg">
<title>The parse forest for “Shimmer”</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ambig01-shimmer.svg"/>
</imageobject>
</mediaobject>
</figure>

<para>It is possible for grammars to be infinitely ambigous. Consider
this trivial grammar:</para>

<example xml:id="ambig02">
<title>An infinitely ambiguous grammar</title>
<programlisting linenumbering="unnumbered"
  >expr: expr ; 'a' .</programlisting>
</example>

<para>Parsing “a” yields:</para>

<programlisting linenumbering="unnumbered"
><![CDATA[$ coffeepot -pp -g:examples/ambig02.ixml a
Found 2 possible parses (of infinitely many).
<expr xmlns:ixml="http://invisiblexml.org/NS" ixml:state="ambiguous">a</expr>]]></programlisting>

<para>There are 2 parses because there’s one choice of two paths in the graph. A description of
the ambiguity, reveals that there are infinitely many parses:</para>

<programlisting linenumbering="unnumbered"
><![CDATA[$ coffeepot -pp -g:examples/ambig02.ixml --describe-ambiguity --no-output a
Found 2 possible parses (of infinitely many).
At /expr
      expr«1-1»
    ✔ 'a'«1-1»]]></programlisting>

<para>This is also evident in the graph:</para>

<figure xml:id="ambig02.svg">
<title>The forest for an infinitely ambiguous parse</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/ambig02.svg"/>
</imageobject>
</mediaobject>
</figure>

<para>That loop is the source of infinite ambiguity. Subject to limitations of
memory and time,
<application>coffeepot</application> will enumerate an arbitrary number of them:</para>

<programlisting linenumbering="unnumbered"
><![CDATA[$ coffeepot -pp -g:examples/ambig02.ixml --parse-count:4 a
Found 2 possible parses (of infinitely many).
<ixml parses="4" totalParses="4" infinitelyAmbiguous="true">
<expr xmlns:ixml='http://invisiblexml.org/NS' ixml:state='ambiguous'>a</expr>
<expr xmlns:ixml='http://invisiblexml.org/NS' ixml:state='ambiguous'>
   <expr>a</expr>
</expr>
<expr xmlns:ixml='http://invisiblexml.org/NS' ixml:state='ambiguous'>
   <expr>
      <expr>a</expr>
   </expr>
</expr>
<expr xmlns:ixml='http://invisiblexml.org/NS' ixml:state='ambiguous'>
   <expr>
      <expr>
         <expr>a</expr>
      </expr>
   </expr>
</expr>
</ixml>
]]></programlisting>

<para>The default “sequential” tree selector will choose every node
and every edge at least once. For graphs without loops, this matches
the number of parses reported. Tree construction from graphs that
contain loops is challenging. The total number of parses reported does
not take loops into consideration. Consider:</para>

<programlisting language="ixml"><xi:include href="examples/horror.ixml" parse="text"/></programlisting>

<para>The only input that parses is the single letter “t”:</para>

<screen><![CDATA[coffeepot -g:src/website/xml/examples/horror.ixml --pretty-print t
Found 12 possible parses (of infinitely many).
<S xmlns:ixml="http://invisiblexml.org/NS" ixml:state="ambiguous">
   <A>
      <B>
         <E>
            <I>t</I>
         </E>
      </B>
   </A>
</S>]]></screen>

<para>The claim of 12 parses is based on the number of choices in the graph.
But the graph is pernicously looped:</para>

<figure>
<title>A perniciously looped graph</title>
<mediaobject>
<imageobject>
  <imagedata fileref="images/horror.svg"/>
</imageobject>
<caption><para>An absurd grammar to test ambiguity handling.</para></caption>
</mediaobject>
</figure>

<para>The priority tree selector will always choose the path with the
highest priority (if there is one). If all choices are made by a
uniquely highest priority in each case, this fact is recorded.
CoffeePot will not report such a parse as ambiguous.</para>

<para>If you’re trying to eliminate ambiguity from a grammar that you think
should be unambiguous, look for multiple ways to match “nothing”. For example,
if you have a nonterminal that matches zero or more whitespace characters,
make sure it isn’t possible for it to match in two different places.
</para>

<section xml:id="describe-ambiguity">
<title>Describing ambiguity</title>

<para>Ambiguity can be described in two ways: using a compact, text format or
using the full XML format that will be used when
<link xlink:href="choose-alternative">choosing alternatives</link> with a function or
XPath expression.</para>

<para>In the examples below, the parse output is from the numbers grammar and input
introduced in <xref linkend="choose-alternative"/>.</para>

<section xml:id="describe-text">
<title>Textual ambiguity descriptions</title>
<para>The text format identifies the location in the result tree with a simple XPath
expression and then lists each option in the form “nonterminal =&gt; right-hand-side”.
An “✔” marks the selected alternative.</para>

<para>For example:</para>

<programlisting><![CDATA[At /number-list/number
    ✔ decimal«10-11»
      hex«10-11»]]></programlisting>

<para>This indicates that at the “number” element in the number list,
there are two choices, “hex” or “decimal”.
Both span input tokens 10-11. The “decimal” alternative has been selected.
</para>
</section>

<section xml:id="describe-xml">
<title>XML ambiguity descriptions</title>
<para>The XML format presents the same information in a XML
fragments that represent the parse trees under consideration.</para>

<para>For example:</para>

<programlisting><![CDATA[At /number-list/number
           <symbol name="number"
                   id="N40"
                   mark="^"
                   start="10"
                   end="11"
                   length="2">
              <parent ref="N22">$8_number-option</parent>
<!-- ✔ -->    <children id="C20">
                 <symbol name="decimal" ref="N49" start="10" end="11" length="2"/>
              </children>
              <children id="C21">
                 <symbol name="hex" ref="N51" start="10" end="11" length="2"/>
              </children>
           </symbol>]]></programlisting>

<para>As before, this indicates that at the “number” element,
there are two choices, represented by separate <tag>children</tag> elements.
</para>
</section>

</section>

</chapter>
